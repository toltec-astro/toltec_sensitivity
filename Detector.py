from .LMTAtmosphere import LMTAtmosphere
from matplotlib import pyplot as plt
import scipy.constants as sc
import numpy as np

class Detector:
  
    def __init__(self,
                 band=1.1,  #band choice (1.1, 1.4, or 2.0)
                 elevation=60.,
                 atmQuartile=25,
                 TcoldBox = 5.75,
                 detectorOpticalEfficiency=0.8,
                 detectorNoiseFactor=0.334,
                 hornApertureEfficiency=0.35,
                 telescopeRMSmicrons=76.):
        
        #array parameters
        if(band == 1.1):
            self.band = 1.1
            self.freq = 280.
            self.nDetectors = 3619
            self.fwhmArcsec = 5.0
        elif(band == 1.4):
            self.band = 1.4
            self.freq = 220.
            self.nDetectors = 2429
            self.fwhmArcsec = 6.3
        elif(band == 2.0):
            self.band = 2.0
            self.freq = 150.
            self.nDetectors = 1114
            self.fwhmArcsec = 9.5
        else:
            raise ValueError('Only bands 1.1, 1.4 and 2.0 are supported.')
            
        #more class members
        self.nPixels = self.nDetectors/2
        self.detectorOpticalEfficiency = detectorOpticalEfficiency
        self.hornApertureEfficiency = hornApertureEfficiency
        self.detNoiseFactor = detectorNoiseFactor
        self.elevation=elevation
        self.atmQuartile=atmQuartile
        self.TcoldBox = TcoldBox
        
        #telescope specific parameters
        self.telRms = telescopeRMSmicrons*1.e-6   #effective rms in meters
        self.telEmis = 0.06    #effective emissivity of telescope
        self.update()
        
    
    #call this function after interactively changing one of the member
    #parameters above.  This will update all calculated values.    
    def update(self):
        #fetch the passband
        self.getPassband()
        
        #telescope and atmosphere
        self.telAtm = LMTAtmosphere(elevation=self.elevation, \
                                     quartile=self.atmQuartile, \
                                     path='/home/toltec/toltec_astro/tolteca/tolteca/web/templates/common/toltec_sensitivity/')
        self.telEfficiency = self.primaryOpticalEfficiency()

        #RJ temperatures and system efficiency
        self.Toptics = self.getToptics()
        self.TatDetectors = self.getTatDetectors()
        self.sysEfficiency = self.getSystemEfficiency()

        #noise and sensitivity
        self.P0, self.net, self.nefd, self.nep = self.getNetAndNep()
        self.mappingSpeed = self.getMappingSpeed()
        

    #passbands
    #passbanss are models generated by Sean Bryan.  We can update
    #these as we get measurements from Cardiff or in-situ measurements
    #with TolTEC itself.  Note that for some reason the fmin and fmax
    #values given here do not match the actual cutoff of the passbands.
    def getPassband(self, passbandFile='model_passbands.npz'):
        passbandFile = '/home/toltec/toltec_astro/tolteca/tolteca/web/templates/common/toltec_sensitivity/model_passbands.npz'
        tmp = np.load(passbandFile)
        self.f_GHz = tmp['f_GHz'][:50000]
        if (self.band==1.1):
            self.passband = tmp['band_280'][:50000]+1.0e-10
            self.fmin = 245.
            self.fmax = 310.
        elif(self.band==1.4):
            self.passband = tmp['band_220'][:50000]+1.0e-10
            self.fmin = 195.
            self.fmax = 245.
        else:
            self.passband = tmp['band_150'][:50000]+1.0e-10
            self.fmin = 128.
            self.fmax = 170.
        #take care of slightly negative values
        self.passband = np.array([x if x>0 else 1.e-10 for x in self.passband])

            
    #make a plot of the passband        
    def plotPassband(self):
        plt.ion()
        plt.plot(self.f_GHz,self.passband)
        plt.xlabel('[GHz]')
        plt.ylabel('[Passband]')


    #make a plot of the atmosphere model
    def plotAtmosphere(self):
        plt.ion()
        plt.plot(self.f_GHz, self.telAtm.T(self.f_GHz))
        plt.xlabel('[GHz]')
        plt.ylabel('T atmosphere')


    #optical efficiency of LMT    
    #this is just the Ruze formula
    def primaryOpticalEfficiency(self):
        f = self.f_GHz*1.e9
        return np.exp(-((4.0*np.pi*self.telRms)/(sc.c/f))**2)
        

    #effective temperature due to optics
    #this is the loading incident on the cryostat window
    def effectiveOpticsTemperature(self):
        #include atmosphere, telescope and coupling optics
        T_tot = self.telAtm.T(self.f_GHz) + \
                self.telEmis*273.    + \
                3.*290.*0.01    
        return T_tot

    
    #effective temperature for loading calculation at detector
    #note that the "horn aperture efficiency" is actually the
    #internal system aperture efficiency since it includes the 
    #truncation of the lyot stop and the loss to the cold optics
    def getEffectiveTemperatureAtDetectors(self):
        Twindow = self.effectiveOpticsTemperature() * \
                 self.detectorOpticalEfficiency * \
                 self.passband * \
                 self.hornApertureEfficiency        
        TcoldBox = self.TcoldBox * \
                 self.detectorOpticalEfficiency * \
                 self.passband * \
                 (1.-self.hornApertureEfficiency)        
        return Twindow+TcoldBox


    #system efficiency
    def getSystemEfficiency(self):
        sysEff = self.detectorOpticalEfficiency * \
                 self.passband * \
                 self.hornApertureEfficiency * \
                 self.telEfficiency
        return sysEff
    

    #noise calculations
    #strategy is to do this for each frequency bin and then do a 
    #weighted average across the band.  This is copied directly from
    #Sean's python code.
    def getNetAndNep(self):
        f = self.f_GHz*1.e9
        df = np.mean(np.diff(f))
        TatDetectors = self.getEffectiveTemperatureAtDetectors()
        dP0 = self.dPowerRJ(TatDetectors,df)
        dnep = self.dBlip(dP0,TatDetectors,f,df)
        dnet = self.dNet(dP0,TatDetectors,f,df)

        #add detector noise
        dnet, dnep = self.addDetNoise(dnet, dnep)

        #nefd
        dnefd = self.getNefd(dnep,48.,df)

        #scale by atmospheric transmission
        dnet = dnet/self.telAtm.tx(self.f_GHz)
        dnefd = dnefd/self.telAtm.tx(self.f_GHz)

        #integrate these up
        net = np.sqrt(1.0 / np.nansum(dnet**(-2.0)))
        nefd = np.sqrt(1.0 / np.nansum(dnefd**(-2.0)))
        # nep is sum of squares
        nep = np.sqrt(np.nansum(dnep**2.0))
        # power just adds
        P0 = np.nansum(dP0)
        return P0, net, nefd, nep

    
    #Detector noise supporting calculations
    #again these have all been rewritten from Sean's python code
    def dPowerRJ(self, T, df): #power from RJ source in frequency bin df
        """ Return the Rayleigh-Jeans power from a source
        Inputs: 
        T [K] - temperature of source
        df [Hz] - frequency bin width
        """
        return sc.k*T*df

    
    def dBlip(self, dP0, T, f, df):
        """ Return the blip noise in W*rt(s) due to optical bin df
        Inputs:
        dP0 [W] - optical power loading in frequncy bin df
        T [K] - effective temperature of loading
        f [Hz] - frequency
        df [Hz] - frequency bin width
        """
        shot = 2.*sc.k*T*sc.h*f*df
        wave = 2.*dP0**2/df
        return np.sqrt(shot+wave)

    
    def dNet(self, dP0, T, f, df):
        Tcmb = 2.725
        dnep = self.dBlip(dP0,T,f,df)
        x = sc.h*f/(sc.k*Tcmb)
        netIntegrand = (sc.k*x)**2.*(1./sc.k)*np.exp(x)/(np.exp(x)-1.)**2.
        dnet = (dnep/(np.sqrt(2.0)*self.sysEfficiency*netIntegrand*df))*1.0e6 
        return dnet

    
    def addDetNoise(self, dnet, dnep):
        fac = 1.+self.detNoiseFactor
        return dnet*np.sqrt(fac), dnep*np.sqrt(fac)

    
    def getNefd(self, dnep, telDia, df):
        #this in mJyrtHz
        dnefd = (dnep*2.0e26*1.e3) / ((np.pi*(telDia/2.0)**2)*df)
        dnefd = dnefd/self.sysEfficiency
        #convert to nJyrts
        dnefd = dnefd/np.sqrt(2.0)
        return dnefd
    
    
    #generates the mapping speed in deg^2/mJy^2/hr
    def getMappingSpeed(self):
        N_beams_in_sqdeg = (60.0*60.0)**2 / ((self.fwhmArcsec**2)*(np.pi/(4.0*np.log(2.0))))
        mapping_speed = (1.0/self.nefd)**2 * self.nDetectors * (3600.0/N_beams_in_sqdeg)
        return mapping_speed

    #calculates a weighted average of the loading in Temperature units
    #incident on the cryostat window
    def getToptics(self):
        to = self.effectiveOpticsTemperature()
        se = self.getSystemEfficiency()
        Teff = np.sum(to*se)/np.sum(se)
        return Teff
    
    #calculates a weighted average of the loading in Temperature units
    #at the detectors 
    #Todo - this isn't really right ... needs work.
    def getTatDetectors(self):
        td = self.getEffectiveTemperatureAtDetectors()
        se = self.passband
        Teff = np.sum(td*se)/np.sum(se)
        return Teff

    #prints a summary of what's been calculated
    def summary(self):
        print(' ')
        print("Elevation = {0:4.2f}".format(self.elevation)+ 'deg:')
        print("Atm Quartile: {0:2d}".format(self.atmQuartile) + "%")
        print("Band: {0:4.2f}".format(self.freq) + " GHz")
        print("Loading: {0:4.2f}".format(self.P0*1.e12) + " pW")
        print("Effective T at window: {0:4.2f}".format(self.Toptics) + " K")
        print("Effective T at detectors: {0:4.2f}".format(self.TatDetectors) + " K")
        print("NEP at Detector: {0:4.2f}".format(self.nep*1.e18) + " aWrts")
        print("NET_CMB: {0:4.2f}".format(self.net) + " uKrts")
        print("NEFD: {0:4.2f}".format(self.nefd) + " mJyrts")
        print("MappingSpeed: {0:4.2f}".format(self.mappingSpeed) + " deg^2/mJy^2/hr")
        
